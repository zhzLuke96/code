# 背包问题

dp问题，其实从根本来说就是一种反证法的特殊运用，在dp中，往往我们第一步将会拟定我们的问题是可解并已经解决之前的过程，作为最后一步，我们就关系当下就行。同时在每一步中我们会将问题的规模缩减，最主要的是缩减上下限

这也是通过这个模式将从前往后的思维模式转换为了从最后一个问题出发的模式

# 01背包
有N件物品和一个容量为V的背包。选择拿取第i件物品需要消耗Wi的体积，但可以得到Ci的价值，求拿取哪些物品可以使得价格最大。

通过通用的模式，我们可以从问题中定义我们的方程

> F[i,V]

即，当我们从前i个物品中选择容量为V的背包能拿到最多的价格，转移方程也很简单，对于任意一步，我们的选择只有两个

- 选择这个物品，导致背包容量减少，并且增加了价值
> F[i-1,V-Ci] + Wi
- 不选这个物品，则缩小备选物品数组
> F[i-1,V]

> F[i,V] = MAX{ F[i-1, V] , F[ i-1, V-Ci] + Wi}

```js
const MAX = (a,b) => a>b?a:b
const items = [{cost:...,weight:...}...]
function solution(i,V){
    if(i <= 0)return 0
    const item = itesm[i]
    if(item.weight > V)[
        return solution(i-1,V)
    ]
    return MAX(solution(i-1,V),solution(i-1,V-item.weight)+item.cost)
}
```

> 简单变种：对于这个问题会出现常见的两种解答案，一种是求问刚好装满背包的，有的则并不会表明是否需要装满，关键在于如何初始化第一行数据

